//
// Port of kvm-hello-world.c to Rust
//
// The C version exercises the KVM API by creating a VM, assigning it some
// memory and VCPUs and starting it in one of the x86-64 processor modes.
//
// Author: Tim Potter <tpot@frungy.org>
//

// File descriptor creation and manipulation
use std::os::fd::{AsRawFd, FromRawFd, OwnedFd};
use std::num::NonZeroUsize;

// Rust-friendly bindings to various system functions
use nix::{
    fcntl,
    fcntl::OFlag,
    sys::stat::Mode,
    ioctl_none_bad,
    ioctl_read,
    ioctl_write_int_bad,
    ioctl_write_ptr,
    request_code_none,
    sys::{mman, mman::MapFlags, mman::ProtFlags},
};

// FFI bindings autogenerated from linux/kvm.h
use kvm_bindings::{
    KVMIO,
    KVM_API_VERSION,
    kvm_userspace_memory_region,
    kvm_run,
    kvm_regs,
    kvm_sregs,
    KVM_EXIT_HLT,
    KVM_EXIT_IO,
};

const KVM_DEVICE: &str = "/dev/kvm";
const MAP_SIZE: usize = 0x1000;

// Unfortunately the kvm_bindings crate does not export ioctl sequence numbers
// so we must hardcode them and use "bad" ioctls.
ioctl_none_bad!(kvm_get_api_version,    request_code_none!(KVMIO, 0x00));
ioctl_none_bad!(kvm_create_vm,          request_code_none!(KVMIO, 0x01));
ioctl_none_bad!(kvm_create_vcpu,        request_code_none!(KVMIO, 0x41));
ioctl_none_bad!(kvm_get_vcpu_mmap_size, request_code_none!(KVMIO, 0x04));

ioctl_write_ptr!(kvm_set_user_memory_region, KVMIO, 0x46, kvm_userspace_memory_region);

ioctl_write_int_bad!(kvm_run, request_code_none!(KVMIO, 0x80));

ioctl_write_ptr!(kvm_set_regs,  KVMIO, 0x82, kvm_regs);
ioctl_read!(kvm_get_sregs,      KVMIO, 0x83, kvm_sregs);
ioctl_write_ptr!(kvm_set_sregs, KVMIO, 0x84, kvm_sregs);

struct Vm {
    sys_fd: OwnedFd,
    vm_fd: OwnedFd,
    mem: u64,
}

struct Vcpu<'a> {
    vm: &'a Vm,
    vcpu_fd: OwnedFd,
    kvm_run: *mut kvm_run,
}

impl Vm {

    // Create new VM
    pub fn new() -> Result<Self, nix::Error> {

        // Open /dev/kvm
        let sys_fd: OwnedFd = match fcntl::open(KVM_DEVICE, OFlag::O_RDWR, Mode::empty()) {
            Ok(fd) => unsafe {
                assert!(fd != -1);
                FromRawFd::from_raw_fd(fd)
            },
            Err(errno) => return Err(errno),
        };

        println!("sys_fd = {0}", AsRawFd::as_raw_fd(&sys_fd));

        // Get KVM API version
        let api_ver = match unsafe {
            kvm_get_api_version(AsRawFd::as_raw_fd(&sys_fd))
        } {
            Ok(result) => {
                assert!(result == KVM_API_VERSION as i32, "Unknown KVM API version: {result}");
                result
            },
            Err(errno) => return Err(errno),
        };

        println!("KVM API version = {api_ver}");

        // Create a VM
        let vm_fd: OwnedFd = match unsafe {
            kvm_create_vm(AsRawFd::as_raw_fd(&sys_fd))
        } {
            Ok(fd) => unsafe {
                assert!(fd != -1);
                FromRawFd::from_raw_fd(fd)
            },
            Err(errno) => return Err(errno),
        };

        println!("vm_fd = {0}", AsRawFd::as_raw_fd(&vm_fd));

        // Create and attach memory
        let mem = match unsafe {
            mman::mmap_anonymous(
                None,
                NonZeroUsize::new(MAP_SIZE).expect("User memory size is zero"),
                ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,
                MapFlags::MAP_SHARED,
            )
        } {
            Ok(result) => {
                result.as_ptr() as u64
            },
            Err(errno) => return Err(errno),
        };

        match unsafe {
            kvm_set_user_memory_region(
                AsRawFd::as_raw_fd(&vm_fd),
                &kvm_userspace_memory_region {
                    slot: 0,
                    flags: 0,
                    guest_phys_addr: 0x1000,
                    memory_size: MAP_SIZE as u64,
                    userspace_addr: mem,
                },
            )
        } {
            Ok(_) => {},
            Err(errno) => return Err(errno),
        };

        Ok(Self{
            sys_fd,
            vm_fd,
            mem,
        })
    }
}

impl<'a> Vcpu<'a> {

    pub fn new(vm: &'a Vm) -> Result<Self, nix::Error> {

        // Create a vCPU for the VM
        let vcpu_fd: OwnedFd = match unsafe {
            kvm_create_vcpu(AsRawFd::as_raw_fd(&vm.vm_fd))
        } {
            Ok(fd) => unsafe {
                assert!(fd != -1);
                FromRawFd::from_raw_fd(fd)
            },
            Err(errno) => return Err(errno),
        };

        println!("kvm_vcpu_fd = {0}", AsRawFd::as_raw_fd(&vcpu_fd));

        // Create kvm_run struct for this VCPU
        let vcpu_mmap_size: NonZeroUsize = match unsafe {
            kvm_get_vcpu_mmap_size(AsRawFd::as_raw_fd(&vm.sys_fd))
        } {
            Ok(result) => {
                NonZeroUsize::new(result as usize).expect("mmap_size is zero")
            },
            Err(errno) => return Err(errno),
        };

        println!("vcpu_mmap_size = {vcpu_mmap_size}");

        let kvm_run: *mut kvm_run = match unsafe {
            mman::mmap(
                None,
                vcpu_mmap_size,
                ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,
                MapFlags::MAP_SHARED,
                &vcpu_fd,
                0,
            )
        } {
            Ok(result) => {
                result.as_ptr() as *mut kvm_run
            },
            Err(errno) => return Err(errno),
        };

        Ok(Self{
            vm,
            vcpu_fd,
            kvm_run,
        })
    }

    pub fn get_sregs(&self) -> Result<kvm_sregs, nix::Error> {
        let mut sregs: kvm_sregs = Default::default();

        match unsafe {
            kvm_get_sregs(AsRawFd::as_raw_fd(&self.vcpu_fd), std::ptr::addr_of_mut!(sregs))
        } {
            Ok(_) => Ok(sregs),
            Err(errno) => Err(errno),
        }
    }

    pub fn set_sregs(&self, sregs: &kvm_sregs) -> Result<(), nix::Error> {
        match unsafe {
            kvm_set_sregs(AsRawFd::as_raw_fd(&self.vcpu_fd), std::ptr::addr_of!(*sregs))
        } {
            Ok(_) => Ok(()),
            Err(errno) => Err(errno),
        }
    }

    pub fn set_regs(&self, regs: &kvm_regs) -> Result<(), nix::Error> {
        match unsafe {
            kvm_set_regs(AsRawFd::as_raw_fd(&self.vcpu_fd), std::ptr::addr_of!(*regs))
        } {
            Ok(_) => Ok(()),
            Err(errno) => Err(errno),
        }
    }

    pub fn run_vm(&self) -> Result<(), nix::Error>
    {
        // Some code to perform some IO and halt, copied from https://lwn.net/Articles/658511/
        let code:[u8; 12]  = [
            0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */
            0x00, 0xd8,       /* add %bl, %al */
            0x04, 0x30,       /* add $'0', %al */
            0xee,             /* out %al, (%dx) */
            0xb0, 0x0a,       /* mov $'\n', %al */
            0xee,             /* out %al, (%dx) */
            0xf4,             /* hlt */
        ];

        // Copy code into VM memory
        unsafe {
            std::ptr::copy_nonoverlapping(code.as_ptr(), self.vm.mem as *mut u8, code.len());
        };

        loop {

            // Call kvm_run()
            match unsafe {
                kvm_run(AsRawFd::as_raw_fd(&self.vcpu_fd), 0)
            } {
                Ok(_) => { },
                Err(errno) => return Err(errno),
            };

            // Check exit reason
            match unsafe {
                (*self.kvm_run).exit_reason
            } {
                KVM_EXIT_IO => {
                    let io_info = unsafe { (*self.kvm_run).__bindgen_anon_1.io };
                    println!("I/O dir={0} port={1:#02x} size={2} count={3}",
                        io_info.direction, io_info.port, io_info.size, io_info.count);
                },
                KVM_EXIT_HLT => {
                    println!("Program halted");
                    break;
                }
                x => {
                    println!("Unknown exit reason, {x}");
                    return Ok(());
                }
            };

        };

        Ok(())
    }

    pub fn run_real_mode(&self) -> Result<(), nix::Error> {
        let mut sregs: kvm_sregs = self.get_sregs().unwrap();

        sregs.cs.selector = 0;
        sregs.cs.base = 0;

        self.set_sregs(&sregs).unwrap();

        let mut regs: kvm_regs = Default::default();

        regs.rip = 0x1000;
        regs.rax = 2;
        regs.rbx = 2;
        regs.rflags = 0x02;

        self.set_regs(&regs).unwrap();

        return self.run_vm();
    }
}

fn main() {

    // Initialise VM
    let vm = Vm::new().expect("Unable to initialise VM");
    let vcpu = Vcpu::new(&vm).expect("Unable to create VCPU");

    vcpu.run_real_mode().expect("Error running VM");
}
