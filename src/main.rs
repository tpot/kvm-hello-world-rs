//
// Port of kvm-hello-world.c to Rust
//
// The C version exercises the KVM API by creating a VM, assigning it some
// memory and VCPUs and starting it in one of the x86-64 processor modes.
//
// Author: Tim Potter <tpot@frungy.org>
//

// File descriptor creation and manipulation
use std::os::fd::{AsRawFd, FromRawFd, OwnedFd};
use std::num::NonZeroUsize;

// Rust-friendly bindings to various system functions
use nix::{
    fcntl,
    fcntl::OFlag,
    sys::stat::Mode,
    ioctl_none_bad,
    ioctl_read,
    ioctl_write_ptr,
    request_code_none,
    sys::{mman, mman::MapFlags, mman::ProtFlags},
};

// FFI bindings autogenerated from linux/kvm.h
use kvm_bindings::{
    KVMIO,
    KVM_API_VERSION,
    kvm_userspace_memory_region,
    kvm_run,
    kvm_regs,
    kvm_sregs,
};

const KVM_DEVICE: &str = "/dev/kvm";
const MAP_SIZE: usize = 0x1000;

// Unfortunately the kvm_bindings crate does not export ioctl sequence numbers
// so we must hardcode them and use "bad" ioctls.
ioctl_none_bad!(kvm_get_api_version,    request_code_none!(KVMIO, 0x00));
ioctl_none_bad!(kvm_create_vm,          request_code_none!(KVMIO, 0x01));
ioctl_none_bad!(kvm_create_vcpu,        request_code_none!(KVMIO, 0x41));
ioctl_none_bad!(kvm_get_vcpu_mmap_size, request_code_none!(KVMIO, 0x04));

ioctl_write_ptr!(kvm_set_user_memory_region, KVMIO, 0x46, kvm_userspace_memory_region);

ioctl_write_ptr!(kvm_set_regs,  KVMIO, 0x82, kvm_regs);
ioctl_read!(kvm_get_sregs,      KVMIO, 0x83, kvm_sregs);
ioctl_write_ptr!(kvm_set_sregs, KVMIO, 0x84, kvm_sregs);

struct Vm {
    sys_fd: OwnedFd,
    vm_fd: OwnedFd,
    mem: u64,
}

struct Vcpu<'a> {
    vm: &'a Vm,
    vcpu_fd: OwnedFd,
    kvm_run: *mut kvm_run,
}

impl Vm {

    // Create new VM
    pub fn new() -> Result<Self, nix::Error> {

        // Open /dev/kvm
        let sys_fd: OwnedFd = match fcntl::open(KVM_DEVICE, OFlag::O_RDWR, Mode::empty()) {
            Ok(fd) => unsafe {
                assert!(fd != -1);
                FromRawFd::from_raw_fd(fd)
            },
            Err(errno) => return Err(errno),
        };

        println!("sys_fd = {0}", AsRawFd::as_raw_fd(&sys_fd));

        // Get KVM API version
        let api_ver = match unsafe {
            kvm_get_api_version(AsRawFd::as_raw_fd(&sys_fd))
        } {
            Ok(result) => {
                assert!(result == KVM_API_VERSION as i32, "Unknown KVM API version: {result}");
                result
            },
            Err(errno) => return Err(errno),
        };

        println!("KVM API version = {api_ver}");

        // Create a VM
        let vm_fd: OwnedFd = match unsafe {
            kvm_create_vm(AsRawFd::as_raw_fd(&sys_fd))
        } {
            Ok(fd) => unsafe {
                assert!(fd != -1);
                FromRawFd::from_raw_fd(fd)
            },
            Err(errno) => return Err(errno),
        };

        println!("vm_fd = {0}", AsRawFd::as_raw_fd(&vm_fd));

        // Create and attach memory
        let mem = match unsafe {
            mman::mmap_anonymous(
                None,
                NonZeroUsize::new(MAP_SIZE).expect("User memory size is zero"),
                ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,
                MapFlags::MAP_ANONYMOUS | MapFlags::MAP_SHARED,
            )
        } {
            Ok(result) => {
                result.as_ptr() as u64
            },
            Err(errno) => return Err(errno),
        };

        match unsafe {
            kvm_set_user_memory_region(
                AsRawFd::as_raw_fd(&vm_fd),
                &kvm_userspace_memory_region {
                    slot: 0,
                    flags: 0,
                    guest_phys_addr: 0,
                    memory_size: MAP_SIZE as u64,
                    userspace_addr: mem,
                },
            )
        } {
            Ok(_) => {},
            Err(errno) => return Err(errno),
        };

        Ok(Self{
            sys_fd,
            vm_fd,
            mem,
        })
    }
}

impl<'a> Vcpu<'a> {

    pub fn new(vm: &'a Vm) -> Result<Self, nix::Error> {

        // Create a vCPU for the VM
        let vcpu_fd: OwnedFd = match unsafe {
            kvm_create_vcpu(AsRawFd::as_raw_fd(&vm.vm_fd))
        } {
            Ok(fd) => unsafe {
                assert!(fd != -1);
                FromRawFd::from_raw_fd(fd)
            },
            Err(errno) => return Err(errno),
        };

        println!("kvm_vcpu_fd = {0}", AsRawFd::as_raw_fd(&vcpu_fd));

        // Create kvm_run struct for this VCPU
        let vcpu_mmap_size: NonZeroUsize = match unsafe {
            kvm_get_vcpu_mmap_size(AsRawFd::as_raw_fd(&vm.sys_fd))
        } {
            Ok(result) => {
                NonZeroUsize::new(result as usize).expect("mmap_size is zero")
            },
            Err(errno) => return Err(errno),
        };

        println!("vcpu_mmap_size = {vcpu_mmap_size}");

        let kvm_run: *mut kvm_run = match unsafe {
            mman::mmap(
                None,
                vcpu_mmap_size,
                ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,
                MapFlags::MAP_SHARED,
                &vcpu_fd,
                0,
            )
        } {
            Ok(result) => {
                result.as_ptr() as *mut kvm_run
            },
            Err(errno) => return Err(errno),
        };

        Ok(Self{
            vm,
            vcpu_fd,
            kvm_run,
        })
    }

    pub fn get_sregs(&self) -> Result<kvm_sregs, nix::Error> {
        let mut sregs: kvm_sregs = Default::default();

        match unsafe {
            kvm_get_sregs(AsRawFd::as_raw_fd(&self.vcpu_fd), std::ptr::addr_of_mut!(sregs))
        } {
            Ok(_) => Ok(sregs),
            Err(errno) => Err(errno),
        }
    }

    pub fn set_sregs(&self, sregs: &kvm_sregs) -> Result<(), nix::Error> {
        match unsafe {
            kvm_set_sregs(AsRawFd::as_raw_fd(&self.vcpu_fd), std::ptr::addr_of!(*sregs))
        } {
            Ok(_) => Ok(()),
            Err(errno) => Err(errno),
        }
    }

    pub fn set_regs(&self, regs: &kvm_regs) -> Result<(), nix::Error> {
        match unsafe {
            kvm_set_regs(AsRawFd::as_raw_fd(&self.vcpu_fd), std::ptr::addr_of!(*regs))
        } {
            Ok(_) => Ok(()),
            Err(errno) => Err(errno),
        }
    }
}

fn main() {

    // Initialise VM
    let vm = Vm::new().expect("Unable to initialise VM");
    let _vcpu = Vcpu::new(&vm).expect("Unable to create VCPU");
}
